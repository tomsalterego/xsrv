### INSTALLATION ###

- name: install wireguard-tools
  apt:
    state: present
    package: wireguard-tools

- name: enable wireguard kernel module
  modprobe:
    name: wireguard
    state: present

- name: create wireguard configuration directories
  file:
    path: "{{ item }}"
    state: directory
    owner: root
    group: root
    mode: "0700"
  with_items:
    - /etc/wireguard
    - /etc/wireguard/private
    - /etc/wireguard/peers
    - /etc/wireguard/peers/private

### KEYS ###

- name: generate wireguard server keys
  shell: "set -o pipefail && wg genkey | (umask 0077 && tee /etc/wireguard/private/server.key) | wg pubkey > /etc/wireguard/private/server.pub"
  args:
    creates: /etc/wireguard/private/server.key
    executable: /bin/bash

- name: get wireguard server private key from file
  slurp:
    src: /etc/wireguard/private/server.key
  register: wireguard_server_private_key
  ignore_errors: "{{ ansible_check_mode }}"

- name: get wireguard server public key from file
  slurp:
    src: /etc/wireguard/private/server.pub
  register: wireguard_server_public_key
  ignore_errors: "{{ ansible_check_mode }}"

# - name: display wireguard server private key
#   debug:
#     msg: "{{ wireguard_server_private_key.content | b64decode }}"
#   ignore_errors: "{{ ansible_check_mode }}"

- name: generate wireguard peers keys
  shell: "set -o pipefail && wg genkey | (umask 0077 && tee /etc/wireguard/peers/private/{{ item.name }}.key) | wg pubkey > /etc/wireguard/peers/{{ item.name }}.pub"
  args:
    creates: "/etc/wireguard/peers/private/{{ item.name }}.key"
    executable: /bin/bash
  with_items: "{{ wireguard_peers }}"
  when: (item.public_key is not defined) and (item.state is not defined or item.state == "present")

- name: remove wireguard peer keys
  file:
    state: absent
    path: "{{ item[1] }}"
  when: (item[0].state is defined) and (item[0].state == "absent")
  with_nested:
    - "{{ wireguard_peers }}"
    - ['/etc/wireguard/peers/{{ item.name }}.pub', '/etc/wireguard/peers/private/{{ item.name }}.key']

### CONFIGURATION ###

- name: copy wireguard server config generation script
  template:
    src: usr_local_bin_wireguard-update-config.j2
    dest: /usr/local/bin/wireguard-update-config # TODO load config from file in /etc
    owner: root
    group: root
    mode: "0700"

- name: run wireguard server config generation script
  command:
    cmd: /usr/local/bin/wireguard-update-config
  register: wireguard_config
  changed_when: '"wg0.conf changed" in wireguard_config.stdout'
  ignore_errors: "{{ ansible_check_mode }}"
  notify: reload wireguard configuration

- name: apply configuration (flush handlers)
  meta: flush_handlers

### DOWNLOAD CLIENT CONFIGURATION FILES ###

- name: create directory for client configuration files on the controller
  delegate_to: localhost
  become: no
  changed_when: no # never return changed, git doesn't store permissions - this task will return changed every time as permissions are changed from 0755 to 0700
  file:
    state: directory
    path: "{{ playbook_dir }}/data/wireguard"
    mode: "0700"

- name: download generated client configuration files
  fetch:
    src: "/etc/wireguard/peers/{{ item.name }}.conf"
    dest: "{{ playbook_dir }}/data/wireguard/{{ inventory_hostname }}-wireguard-{{ item.name }}.conf"
    flat: yes
    mode: "0600"
  with_items: "{{ wireguard_peers }}"
  diff: no # don't show diffs, files contain sensitive private key
  when: (item.public_key is not defined) and (item.state is not defined or item.state == "present")
  ignore_errors: "{{ ansible_check_mode }}"
  changed_when: no # never report as changed, these files are under .gitignore and are not shared between different controllers, this will return changed every time

- name: show information about sending configuration files to clients
  debug:
    msg: "Please provide VPN clients with their client configuration file which was generated in {{ playbook_dir }}/data/wireguard/"


### SERVICE ###

- name: enable/disable start/stop wireguard service
  systemd:
    name: wg-quick@wg0
    enabled: "{{ wireguard_enable_service }}"
    state: "{{ 'started' if wireguard_enable_service else 'stopped' }}"
  ignore_errors: "{{ ansible_check_mode }}"
  register: wireguard_systemd_service

- name: restart netdata
  service:
    name: netdata
    state: restarted
  when:
    - wireguard_systemd_service.changed # noqa no-handler
    - ansible_local.netdata.ansible_managed is defined
    - ansible_local.netdata.ansible_managed | bool
